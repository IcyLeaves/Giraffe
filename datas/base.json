{
  "data": [
    {
      "name": "ObTableScanStoreRowIterator::rescan",
      "x": 776.4414109827362,
      "y": 378.7614436291806,
      "category": 0,
      "symbolSize": [265, 40],
      "extra": {
        "code": "int ObTableScanStoreRowIterator::rescan(const ObRangeArray& key_ranges, const ObPosArray& range_array_pos)\r\n{\r\n  int ret = OB_SUCCESS;\r\n  if (OB_UNLIKELY(!is_inited_)) {\r\n    ret = OB_NOT_INIT;\r\n    STORAGE_LOG(WARN, \"The ObTableScanStoreRowIterator has not been inited, \", K(ret));\r\n  } else if (&scan_param_->key_ranges_ != &key_ranges || &scan_param_->range_array_pos_ != &range_array_pos) {\r\n    ret = OB_ERR_UNEXPECTED;\r\n    STORAGE_LOG(WARN, \"scan_param is not the same\", K(ret), K(scan_param_), K(key_ranges), K(range_array_pos));\r\n  } else {\r\n    STORAGE_LOG(DEBUG, \"table scan iterate rescan\", K_(is_inited), K(scan_param_));\r\n    // there's no need to reset main_table_param_ and index_table_param_\r\n    // scan_param only reset query range fields in ObTableScan::rt_rescan()\r\n    range_iter_.reuse();\r\n    main_iter_ = NULL;\r\n    reuse_row_iters();\r\n    main_table_ctx_.reuse();\r\n    index_table_ctx_.reuse();\r\n    is_iter_opened_ = false;\r\n\r\n    if (OB_FAIL(range_iter_.set_scan_param(*scan_param_))) {\r\n      STORAGE_LOG(WARN, \"set scan param to range iterator failed\", K(ret));\r\n    } else if (OB_FAIL(prepare_table_context(row_filter_))) {\r\n      STORAGE_LOG(WARN, \"fail to prepare table context\", K(ret));\r\n    } else {\r\n      if (OB_FAIL(open_iter())) {\r\n        STORAGE_LOG(WARN, \"fail to open iter\", K(ret));\r\n      } else {\r\n        is_iter_opened_ = true;\r\n      }\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n"
      }
    },
    {
      "name": "ObTableScanStoreRowIterator::open_iter",
      "x": 369.6122136637376,
      "y": 551.1040849171944,
      "category": 0,
      "symbolSize": [286, 40],
      "extra": {
        "code": "int ObTableScanStoreRowIterator::open_iter()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  ObBatch batch;\r\n  void* buf = NULL;\r\n  if (OB_FAIL(range_iter_.get_next(batch))) {\r\n    if (OB_ITER_END != ret) {\r\n      STORAGE_LOG(WARN, \"fail to get batch range\", K(ret));\r\n    } else {\r\n      ret = OB_SUCCESS;\r\n    }\r\n  } else {\r\n    get_table_param_.partition_store_ = partition_store_;\r\n    get_table_param_.frozen_version_ = scan_param_->frozen_version_;\r\n    get_table_param_.sample_info_ = scan_param_->sample_info_;\r\n    switch (batch.type_) {\r\n      case ObBatch::T_GET: {\r\n        if (NULL == single_merge_) {\r\n          if (NULL == (buf = scan_param_->allocator_->alloc(sizeof(ObSingleMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            single_merge_ = new (buf) ObSingleMerge();\r\n            if (OB_FAIL(init_scan_iter(scan_param_->scan_flag_.is_index_back(), *single_merge_))) {\r\n              STORAGE_LOG(WARN, \"Fail to init single merge, \", K(ret));\r\n            } else {\r\n              use_fuse_row_cache_ = !single_merge_->is_read_memtable_only();\r\n            }\r\n          }\r\n        }\r\n        if (OB_SUCC(ret)) {\r\n          main_table_ctx_.use_fuse_row_cache_ = use_fuse_row_cache_;\r\n          if (OB_FAIL(single_merge_->open(*batch.rowkey_))) {\r\n            STORAGE_LOG(WARN, \"Fail to open multiple get merge iterator, \", K(ret));\r\n          } else {\r\n            main_iter_ = single_merge_;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ObBatch::T_MULTI_GET: {\r\n        if (NULL == get_merge_) {\r\n          if (NULL == (buf = scan_param_->allocator_->alloc(sizeof(ObMultipleGetMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            get_merge_ = new (buf) ObMultipleGetMerge();\r\n            if (OB_FAIL(init_scan_iter(scan_param_->scan_flag_.is_index_back(), *get_merge_))) {\r\n              STORAGE_LOG(WARN, \"Fail to init get merge, \", K(ret));\r\n            } else {\r\n              use_fuse_row_cache_ = !get_merge_->is_read_memtable_only();\r\n            }\r\n          }\r\n        }\r\n        if (OB_SUCC(ret)) {\r\n          main_table_ctx_.use_fuse_row_cache_ = use_fuse_row_cache_;\r\n          if (OB_FAIL(get_merge_->open(*batch.rowkeys_))) {\r\n            STORAGE_LOG(WARN, \"Fail to open multiple get merge iterator, \", K(ret));\r\n          } else {\r\n            main_iter_ = get_merge_;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ObBatch::T_SCAN: {\r\n        if (NULL == scan_merge_) {\r\n          if (OB_ISNULL(buf = scan_param_->allocator_->alloc(sizeof(ObMultipleScanMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            scan_merge_ = new (buf) ObMultipleScanMerge();\r\n            if (OB_FAIL(init_scan_iter(scan_param_->scan_flag_.is_index_back(), *scan_merge_))) {\r\n              STORAGE_LOG(WARN, \"Fail to init scan merge, \", K(ret));\r\n            }\r\n          }\r\n        }\r\n\r\n        if (OB_SUCC(ret)) {\r\n          if (scan_param_->sample_info_.is_block_sample()) {\r\n            if (NULL == block_sample_iterator_) {\r\n              if (OB_ISNULL(buf = scan_param_->allocator_->alloc(sizeof(ObBlockSampleIterator)))) {\r\n                ret = OB_ALLOCATE_MEMORY_FAILED;\r\n                STORAGE_LOG(WARN, \"failed to allocate block_sample_iterator_\", K(ret));\r\n              } else {\r\n                block_sample_iterator_ = new (buf) ObBlockSampleIterator(scan_param_->sample_info_);\r\n              }\r\n            }\r\n            if (OB_SUCC(ret)) {\r\n              if (OB_FAIL(block_sample_iterator_->open(*scan_merge_,\r\n                      scan_param_->scan_flag_.is_index_back() ? index_table_ctx_ : main_table_ctx_,\r\n                      *batch.range_,\r\n                      get_table_param_,\r\n                      scan_param_->scan_flag_.is_reverse_scan()))) {\r\n                STORAGE_LOG(WARN, \"failed to open block_sample_iterator_\", K(ret));\r\n              } else {\r\n                main_iter_ = block_sample_iterator_;\r\n              }\r\n            }\r\n          } else {\r\n            if (OB_FAIL(scan_merge_->open(*batch.range_))) {\r\n              STORAGE_LOG(WARN, \"Fail to open multiple scan merge iterator, \", K(ret), K(*scan_param_));\r\n            } else {\r\n              main_iter_ = scan_merge_;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ObBatch::T_MULTI_SCAN: {\r\n        if (NULL == multi_scan_merge_) {\r\n          if (NULL == (buf = scan_param_->allocator_->alloc(sizeof(ObMultipleMultiScanMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            multi_scan_merge_ = new (buf) ObMultipleMultiScanMerge();\r\n            if (OB_FAIL(init_scan_iter(scan_param_->scan_flag_.is_index_back(), *multi_scan_merge_))) {\r\n              STORAGE_LOG(WARN, \"fail to init multi scan merge\", K(ret));\r\n            }\r\n          }\r\n        }\r\n        if (OB_SUCC(ret)) {\r\n          if (OB_FAIL(multi_scan_merge_->open(*batch.ranges_))) {\r\n            STORAGE_LOG(WARN, \"Fail to open multiple multi_scan merge iterator, \", K(ret));\r\n          } else {\r\n            main_iter_ = multi_scan_merge_;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        ret = OB_INVALID_ARGUMENT;\r\n        STORAGE_LOG(WARN, \"invalid batch type\", K(ret), K(batch.type_));\r\n      }\r\n    }\r\n\r\n    if (OB_SUCC(ret)) {\r\n      if (scan_param_->sample_info_.is_row_sample()) {\r\n        if (NULL == row_sample_iterator_) {\r\n          if (OB_ISNULL(buf = scan_param_->allocator_->alloc(sizeof(ObRowSampleIterator)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"failed to allocate memory\", K(ret));\r\n          } else {\r\n            row_sample_iterator_ = new (buf) ObRowSampleIterator(scan_param_->sample_info_);\r\n          }\r\n        }\r\n        if (OB_SUCC(ret)) {\r\n          if (OB_FAIL(row_sample_iterator_->open(*main_iter_))) {\r\n            STORAGE_LOG(WARN, \"failed to open row_sample_iterator\", K(ret));\r\n          } else {\r\n            main_iter_ = row_sample_iterator_;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (OB_SUCC(ret)) {\r\n      if (scan_param_->scan_flag_.is_index_back()) {\r\n        if (NULL == index_merge_) {\r\n          if (NULL == (buf = scan_param_->allocator_->alloc(sizeof(ObIndexMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            index_merge_ = new (buf) ObIndexMerge();\r\n            if (OB_FAIL(index_merge_->init(main_table_param_, index_table_param_, main_table_ctx_, get_table_param_))) {\r\n              STORAGE_LOG(WARN, \"Fail to init index merge, \", K(ret));\r\n            }\r\n          }\r\n        }\r\n\r\n        if (OB_SUCC(ret)) {\r\n          main_table_ctx_.use_fuse_row_cache_ = use_fuse_row_cache_;\r\n          if (OB_FAIL(index_merge_->open(*main_iter_))) {\r\n            STORAGE_LOG(WARN, \"Fail to open index merge iterator, \", K(ret));\r\n          } else {\r\n            main_iter_ = index_merge_;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return ret;\r\n}"
      }
    },
    {
      "name": "ObMultipleScanMerge::open",
      "x": 208.67320091930424,
      "y": 409.42028138576484,
      "category": 0,
      "symbolSize": [195, 40],
      "extra": {
        "code": "int ObMultipleScanMerge::open(const ObExtStoreRange& range)\r\n{\r\n  int ret = OB_SUCCESS;\r\n\r\n  if (OB_UNLIKELY(!range.get_range().is_valid())) {\r\n    STORAGE_LOG(WARN, \"Invalid range, \", K(range), K(ret));\r\n  } else if (OB_FAIL(ObMultipleMerge::open())) {\r\n    STORAGE_LOG(WARN, \"Fail to open ObMultipleMerge, \", K(ret));\r\n  } else if (OB_FAIL(const_cast<ObExtStoreRange&>(range).to_collation_free_range_on_demand_and_cutoff_range(\r\n                 *access_ctx_->allocator_))) {\r\n    STORAGE_LOG(WARN, \"fail to get collation free rowkey\", K(ret));\r\n  } else {\r\n    row_filter_ = NULL;\r\n\r\n    if (NULL != access_ctx_->row_filter_ && tables_handle_.has_split_source_table(access_ctx_->pkey_)) {\r\n      row_filter_ = access_ctx_->row_filter_;\r\n    }\r\n\r\n    range_ = &range;\r\n    if (OB_FAIL(ObMultipleScanMergeImpl::prepare_loser_tree())) {\r\n      STORAGE_LOG(WARN, \"fail to prepare loser tree\", K(ret));\r\n    } else if (OB_FAIL(construct_iters())) {\r\n      STORAGE_LOG(WARN, \"fail to construct iters\", K(ret));\r\n    } else if (OB_UNLIKELY(access_ctx_->need_prewarm())) {\r\n      access_ctx_->store_ctx_->warm_up_ctx_->record_scan(*access_param_, *access_ctx_, *range_);\r\n    }\r\n  }\r\n\r\n  return ret;\r\n}"
      }
    },
    {
      "name": "ObOperator::get_next_row",
      "x": -462.25416964512254,
      "y": 173.33766731235414,
      "symbolSize": [265, 40],
      "category": 0,
      "extra": {
        "code": "int ObOperator::get_next_row()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  if (OB_UNLIKELY(!startup_passed_)) {\r\n    bool filtered = false;\r\n    if (OB_FAIL(startup_filter(filtered))) {\r\n      LOG_WARN(\"do startup filter failed\", K(ret), \"op\", op_name());\r\n    } else {\r\n      if (filtered) {\r\n        ret = OB_ITER_END;\r\n      } else {\r\n        startup_passed_ = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  while (OB_SUCC(ret)) {\r\n    if (OB_FAIL(inner_get_next_row())) {\r\n      if (OB_ITER_END != ret) {\r\n        LOG_WARN(\"inner get next row failed\", K(ret), \"type\", spec_.type_, \"op\", op_name());\r\n      }\r\n    } else {\r\n      if (!spec_.filters_.empty()) {\r\n        bool filtered = false;\r\n        if (OB_FAIL(filter_row(filtered))) {\r\n          LOG_WARN(\"filter row failed\", K(ret), \"type\", spec_.type_, \"op\", op_name());\r\n        } else {\r\n          if (filtered) {\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    break;\r\n  }\r\n\r\n  if (OB_SUCCESS == ret) {\r\n    op_monitor_info_.output_row_count_++;\r\n    if (!got_first_row_) {\r\n      op_monitor_info_.first_row_time_ = oceanbase::common::ObClockGenerator::getClock();\r\n      ;\r\n      got_first_row_ = true;\r\n    }\r\n  } else if (OB_ITER_END == ret) {\r\n    int tmp_ret = drain_exch();\r\n    if (OB_SUCCESS != tmp_ret) {\r\n      LOG_WARN(\"drain exchange data failed\", K(tmp_ret));\r\n    }\r\n    if (got_first_row_) {\r\n      op_monitor_info_.last_row_time_ = oceanbase::common::ObClockGenerator::getClock();\r\n    }\r\n  }\r\n  return ret;\r\n}"
      }
    },
    {
      "name": "ObNestedLoopJoinOp::inner_get_next_row",
      "x": -295.05608741295066,
      "y": 282.86496521159654,
      "symbolSize": [167, 40],
      "category": 0,
      "extra": {
        "code": "int ObNestedLoopJoinOp::inner_get_next_row()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  if (OB_UNLIKELY(LEFT_SEMI_JOIN == MY_SPEC.join_type_ || LEFT_ANTI_JOIN == MY_SPEC.join_type_)) {\r\n    if (OB_FAIL(join_row_with_semi_join())) {\r\n      if (ret != OB_ITER_END) {\r\n        LOG_WARN(\"failed to join row with semi join\", K(ret));\r\n      }\r\n    }\r\n  } else {\r\n    state_operation_func_type state_operation = NULL;\r\n    state_function_func_type state_function = NULL;\r\n    int func = -1;\r\n    output_row_produced_ = false;\r\n    while (OB_SUCC(ret) && !output_row_produced_) {\r\n      state_operation = this->ObNestedLoopJoinOp::state_operation_func_[state_];\r\n      if (OB_ITER_END == (ret = (this->*state_operation)())) {\r\n        func = FT_ITER_END;\r\n        ret = OB_SUCCESS;\r\n      } else if (OB_FAIL(ret)) {\r\n        LOG_WARN(\"failed state operation\", K(ret), K(state_));\r\n      } else {\r\n        func = FT_ITER_GOING;\r\n      }\r\n      if (OB_SUCC(ret)) {\r\n        state_function = this->ObNestedLoopJoinOp::state_function_func_[state_][func];\r\n        if (OB_FAIL((this->*state_function)()) && OB_ITER_END != ret) {\r\n          LOG_WARN(\"failed state function\", K(ret), K(state_), K(func));\r\n        }\r\n      }\r\n    }  // while end\r\n  }\r\n  if (OB_ITER_END == ret) {\r\n    if (OB_FAIL(set_param_null())) {\r\n      LOG_WARN(\"failed to set param null\", K(ret));\r\n    } else {\r\n      ret = OB_ITER_END;\r\n    }\r\n  }\r\n\r\n  return ret;\r\n}"
      }
    },
    {
      "name": "ObNestedLoopJoinOp::read_left_func_going",
      "x": 10.10059375469541,
      "y": 176.1235504837585,
      "symbolSize": [167, 40],
      "category": 0,
      "extra": {
        "code": "int ObNestedLoopJoinOp::read_left_func_going()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  if (MY_SPEC.use_group_) {\r\n    // do nothing\r\n  } else if (!MY_SPEC.rescan_params_.empty()) {\r\n    ObExecContext::ObPlanRestartGuard restart_plan(ctx_);\r\n    if (OB_FAIL(prepare_rescan_params())) {\r\n      LOG_WARN(\"failed to prepare rescan params\", K(ret));\r\n    } else if (OB_FAIL(right_->rescan())) {\r\n      LOG_WARN(\"failed to rescan right op\", K(ret));\r\n    } else { /*do nothing*/\r\n    }\r\n  } else {\r\n    if (OB_FAIL(prepare_rescan_params())) {\r\n      LOG_WARN(\"failed to prepare rescan params\", K(ret));\r\n    } else if (OB_FAIL(right_->rescan())) {\r\n      LOG_WARN(\"failed to rescan right op\", K(ret));\r\n    } else { /*do nothing*/\r\n    }\r\n  }\r\n  state_ = JS_READ_RIGHT;\r\n\r\n  return ret;\r\n}"
      }
    },
    {
      "name": "ObTableScanOp::rescan",
      "x": 184.89434192781243,
      "y": 294.587304654527,
      "symbolSize": [167, 40],
      "category": 0,
      "extra": {
        "code": "int ObTableScanOp::rescan()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  if (ctx_.is_gi_restart()) {\r\n    // this scan is started by a gi operator, so, scan a new range.\r\n    if (OB_FAIL(get_gi_task_and_restart())) {\r\n      LOG_WARN(\"fail to get gi task and scan\", K(ret));\r\n    }\r\n  } else if (MY_SPEC.batch_scan_flag_) {\r\n    // do nothing\r\n  } else if (OB_INVALID_INDEX == MY_INPUT.get_location_idx()) {\r\n    iter_end_ = true;\r\n    if (OB_UNLIKELY(NULL != result_)) {\r\n      ret = OB_ERR_UNEXPECTED;\r\n      LOG_ERROR(\"result_ should be NULL\", K(ret));\r\n    }\r\n  } else if (is_virtual_table(MY_SPEC.ref_table_id_) || MY_SPEC.for_update_) {\r\n    ret = vt_rescan();\r\n  } else if (!range_array_pos.empty()) {\r\n    ret = OB_NOT_SUPPORTED;\r\n    LOG_USER_ERROR(OB_NOT_SUPPORTED, \"Batch iterator rescan\");\r\n  } else {\r\n    ret = rt_rescan();\r\n  }\r\n  return ret;\r\n}"
      }
    },
    {
      "name": "ObTableScanOp::rt_rescan",
      "x": 437.6735124362814,
      "y": 186.91516962694084,
      "symbolSize": [167, 40],
      "category": 0,
      "extra": {
        "code": "int ObTableScanOp::rt_rescan()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  if (OB_FAIL(reset_query_range())) {\r\n    LOG_WARN(\"failed to reset query range\", K(ret));\r\n  } else if (OB_FAIL(add_query_range())) {\r\n    LOG_WARN(\"failed to add query range\", K(ret));\r\n  } else if (OB_FAIL(rescan_after_adding_query_range())) {\r\n    LOG_WARN(\"failed to rescan\", K(ret));\r\n  } else {\r\n  }\r\n  return ret;\r\n}"
      }
    },
    {
      "name": "ObTableScanOp::rescan_after_adding_query_range",
      "x": 570.1850914245756,
      "y": 303.970915652195,
      "symbolSize": [167, 40],
      "category": 0,
      "extra": {
        "code": "int ObTableScanOp::rescan_after_adding_query_range()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  if (OB_FAIL(ObOperator::rescan())) {\r\n    LOG_WARN(\"rescan operator failed\", K(ret));\r\n  } else if (OB_ISNULL(result_)) {\r\n    ret = OB_ERR_UNEXPECTED;\r\n    LOG_ERROR(\"result_ is NULL\", K(ret));\r\n  } else if (MY_SPEC.is_vt_mapping_ && OB_FAIL(vt_result_converter_->convert_key_ranges(scan_param_.key_ranges_))) {\r\n    LOG_WARN(\"failed to convert key ranges\", K(ret));\r\n  } else if (OB_FAIL(static_cast<ObTableScanIterator*>(result_)->rescan(scan_param_))) {\r\n    LOG_WARN(\"failed to rescan\", K(ret), K(scan_param_));\r\n  } else {\r\n    iter_end_ = false;\r\n  }\r\n  return ret;\r\n}"
      }
    },
    {
      "name": "ObTableScanIterIterator::rescan",
      "x": 822.4694503845063,
      "y": 181.61210882460202,
      "symbolSize": [167, 40],
      "category": 0,
      "extra": {
        "code": "int ObTableScanIterIterator::rescan(ObTableScanParam& scan_param)\r\n{\r\n  int ret = OB_SUCCESS;\r\n  range_row_iter_.reset();\r\n  if (OB_FAIL(store_row_iter_.rescan(scan_param.key_ranges_, scan_param.range_array_pos_))) {\r\n    STORAGE_LOG(WARN, \"fail to rescan\", K(ret));\r\n  } else if (OB_FAIL(range_row_iter_.init(scan_param.scan_flag_.is_reverse_scan(), store_row_iter_))) {\r\n    STORAGE_LOG(WARN, \"fail to init range row iterator\", K(ret));\r\n  } else {\r\n    const int64_t range_array_cnt = scan_param.range_array_pos_.count();\r\n    is_reverse_scan_ = scan_param.scan_flag_.is_reverse_scan();\r\n    range_array_cnt_ = 0 == range_array_cnt ? 1 : range_array_cnt;  // zero range means whole range\r\n    range_array_cursor_ = is_reverse_scan_ ? range_array_cnt_ : -1;\r\n  }\r\n  return ret;\r\n}"
      }
    }
  ],
  "links": [
    { "source": 0, "target": 1 },
    { "source": 1, "target": 2 },
    { "source": 3, "target": 4 },
    { "source": 4, "target": 5 },
    { "source": 5, "target": 6 },
    { "source": 6, "target": 7 },
    { "source": 7, "target": 8 },
    { "source": 8, "target": 9 },
    { "source": 9, "target": 0 }
  ],
  "categories": [
    { "name": "蓝色", "itemStyle": { "color": "#5470C5" } },
    { "name": "紫色", "itemStyle": { "color": "#C678DD" } }
  ]
}
