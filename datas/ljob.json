{"nodes":[{"id":"0","label":"ObNestedLoopJoinOp::inner_get_next_row","x":-551.796062018245,"y":137.7501527336515,"size":[286,40],"category":5,"extra":{"code":"int ObNestedLoopJoinOp::inner_get_next_row()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  state_operation_func_type state_operation = NULL;\r\n  state_function_func_type state_function = NULL;\r\n  int func = -1;\r\n  output_row_produced_ = false;\r\n  while (OB_SUCC(ret) && !output_row_produced_) {\r\n    state_operation = this->ObNestedLoopJoinOp::state_operation_func_[state_];\r\n    ret = (this->*state_operation)();\r\n    if(ret == OB_ITER_END) {\r\n      func = FT_ITER_END;\r\n      ret = OB_SUCCESS;\r\n    }\r\n    else {\r\n      func = FT_ITER_GOING;\r\n    }\r\n    state_function = this->ObNestedLoopJoinOp::state_function_func_[state_][func];\r\n    ret = (this->*state_function)();\r\n  }  // while end\r\n  if (OB_ITER_END == ret) {\r\n    set_param_null()\r\n    ret = OB_ITER_END;\r\n  }\r\n\r\n  return ret;\r\n}"}},{"id":"1","label":"ObNestedLoopJoinOp::read_left_operate","x":11.25720545914993,"y":-108.15603525264046,"size":[279,40],"category":5,"extra":{"code":"int ObNestedLoopJoinOp::read_left_operate()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  ret = get_next_left_row();\r\n  return ret;\r\n}"}},{"id":"2","label":"ObNestedLoopJoinOp::read_left_func_going","x":-83.5503444174758,"y":106.42691002485495,"size":[300,40],"category":5,"extra":{"code":"int ObNestedLoopJoinOp::read_left_func_going()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  assert(!MY_SPEC.rescan_params_.empty())\r\n  ObExecContext::ObPlanRestartGuard restart_plan(ctx_);\r\n  prepare_rescan_params();\r\n  right_->rescan();\r\n  state_ = JS_READ_RIGHT;\r\n  return ret;\r\n}"}},{"id":"3","label":"ObNestedLoopJoinOp::read_right_operate","x":-42.39720201152011,"y":363.88319717816194,"size":[286,40],"category":5,"extra":{"code":"int ObNestedLoopJoinOp::read_right_operate()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  ret = get_next_right_row();//OB_ITER_END\r\n  clear_evaluated_flag();\r\n  return ret;\r\n}"}},{"id":"4","label":"ObNestedLoopJoinOp::read_right_func_end","x":-187.94218089553863,"y":666.1420391813112,"size":[293,40],"category":5,"extra":{"code":"int ObNestedLoopJoinOp::read_right_func_end()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  if (need_left_join() && !left_row_joined_) {\r\n    output_row_produced_ = true;\r\n    blank_right_row();\r\n  }\r\n  state_ = JS_READ_LEFT;\r\n\r\n  return ret;\r\n}"}},{"id":"5","label":"SELECT /*+ordered use_nl(A,B)*/ * FROM t1 A, t2 B WHERE A.c1 >= 511 and A.c1 < 514 and A.c2 = B.c2 and A.c3 = B.c3;","x":-90.56510283833597,"y":-216.0818337142074,"size":[825,40],"category":0,"extra":{"code":"hello,world"}},{"id":"6","label":"OB_ITER_END","x":143.3560870103476,"y":-2.018812792401036,"size":[97,40],"category":18,"extra":{"code":"hello,world"}},{"id":"7","label":"OB_SUCCESS","x":-33.478309007357836,"y":-1.7171934324831284,"size":[90,40],"category":18,"extra":{"code":"hello,world"}},{"id":"8","label":"ObNestedLoopJoinOp::read_left_func_end","x":251.56903076257925,"y":253.12709933522973,"size":[286,40],"category":5,"extra":{"code":"int ObNestedLoopJoinOp::read_left_func_end()\r\n{\r\n  state_ = JS_JOIN_END;\r\n  return OB_ITER_END;\r\n}"}},{"id":"9","label":"JS_JOIN_END","x":549.3998421315553,"y":224.44198147529525,"size":[97,40],"category":18,"extra":{"code":"hello,world"}},{"id":"10","label":"JS_READ_RIGHT","x":-272.99150910628646,"y":266.7690011209314,"size":[111,40],"category":18,"extra":{"code":"hello,world"}},{"id":"11","label":"JS_READ_LEFT","x":-317.3227051356004,"y":24.73251207278281,"size":[104,40],"category":18,"extra":{"code":"hello,world"}},{"id":"12","label":"OB_ITER_END ","x":-139.35264370205147,"y":441.53016518766094,"size":[104,40],"category":18,"extra":{"code":"hello,world"}},{"id":"13","label":"OB_ITER_END  ","x":546.4644548332824,"y":292.6972487995793,"size":[111,40],"category":18,"extra":{"code":"hello,world"}},{"id":"14","label":"ObNestedLoopJoinOp::read_right_func_going","x":134.16163244007794,"y":504.3280769459285,"size":[307,40],"category":5,"extra":{"code":"int ObNestedLoopJoinOp::read_right_func_going()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  bool is_match = false;\r\n  calc_other_conds(is_match));\r\n  if (is_match) {\r\n    output_row_produced_ = true;\r\n    left_row_joined_ = true;  // left row joined sign.\r\n  }\r\n  return ret;\r\n}"}},{"id":"15","label":"OB_SUCCESS ","x":34.23565944995181,"y":434.85480218795794,"size":[97,40],"category":18,"extra":{"code":"hello,world"}},{"id":"16","label":"ObBasicNestedLoopJoin::prepare_rescan_params","x":799.8514861109832,"y":22.29290086434385,"size":[328,40],"category":10,"extra":{"code":"int ObBasicNestedLoopJoin::prepare_rescan_params(ObBasicNestedLoopJoinCtx& join_ctx) const\r\n{\r\n  int ret = OB_SUCCESS;\r\n  ObObjParam res_obj;\r\n  ObPhysicalPlanCtx *plan_ctx = join_ctx.exec_ctx_.get_physical_plan_ctx();\r\n  ObPhyOperator *left_child = get_child(FIRST_CHILD);\r\n  ObPhyOperatorCtx *left_child_ctx = NULL;\r\n  left_child_ctx = static_cast<ObPhyOperatorCtx *>(\r\n                  join_ctx.exec_ctx_.get_phy_op_ctx(left_child->get_id()));\r\n  \r\n  int64_t param_cnt = rescan_params_.count();\r\n  const ObSqlExpression *expr = NULL;\r\n  // rescan param need deep copy, because memory of expr result from calc_buf\r\n  // in ObPhyOperator, when get next row next time, will free memory in\r\n  // calc_buf; here we use left child calc_buf, because when left child need\r\n  // get next row, rescan param will not used;\r\n  for (int64_t i = 0; OB_SUCC(ret) && i < param_cnt; ++i) {\r\n    int64_t idx = rescan_params_.at(i).param_idx_;\r\n    expr = rescan_params_.at(i).expr_;\r\n    expr->calc(join_ctx.expr_ctx_, *join_ctx.left_row_, res_obj);\r\n    res_obj.set_param_meta();\r\n    deep_copy_obj(\r\n              left_child_ctx->get_calc_buf(), res_obj,\r\n              plan_ctx->get_param_store_for_update().at(idx));\r\n  }\r\n  \r\n\r\n  // try to open the right child\r\n  if (OB_SUCC(ret)) {\r\n    open_right_child(join_ctx);\r\n  }\r\n\r\n  return ret;\r\n}"}},{"id":"17","label":"ObTableScanOp::rescan","x":726.9243445137156,"y":90.54017064585295,"size":[167,40],"category":6,"extra":{"code":"int ObTableScanOp::rescan()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  ret = rt_rescan();\r\n  return ret;\r\n}"}},{"id":"18","label":"ObTableScanOp::rt_rescan","x":1202.6602888630741,"y":25.077541415709334,"size":[188,40],"category":6,"extra":{"code":"int ObTableScanOp::rt_rescan()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  reset_query_range();\r\n  add_query_range();\r\n  rescan_after_adding_query_range();\r\n  return ret;\r\n}"}},{"id":"19","label":"ObTableScanOp::reset_query_range","x":1578.6275812961153,"y":22.231891944561085,"size":[244,40],"category":6,"extra":{"code":"/*\r\n * the following three functions are used for blocked nested loop join\r\n */\r\nint ObTableScanOp::reset_query_range()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  table_allocator_->reuse();  // reset allocator for prepare\r\n  scan_param_.key_ranges_.reuse();\r\n  scan_param_.range_array_pos_.reuse();\r\n  return ret;\r\n}"}},{"id":"20","label":"ObTableScanOp::add_query_range","x":1571.3914810519677,"y":91.75380178996124,"size":[230,40],"category":6,"extra":{"code":"int ObTableScanOp::add_query_range()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  prepare(true);// prepare scan input param\r\n  append(scan_param_.key_ranges_, MY_INPUT.key_ranges_);\r\n  assert(MY_INPUT.key_ranges_.count() != 0);\r\n  prune_query_range_by_partition_id(scan_param_.key_ranges_);\r\n  if(scan_param_.key_ranges_.count() == 0)\r\n  {\r\n    scan_param_.key_ranges_.push_back(MY_INPUT.key_ranges_.at(0));\r\n  }\r\n  return ret;\r\n}"}},{"id":"21","label":"ObTableScanOp::rescan_after_adding_query_range","x":1619.4791204335684,"y":153.624305939662,"size":[342,40],"category":6,"extra":{"code":"int ObTableScanOp::rescan_after_adding_query_range()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  ObOperator::rescan();\r\n  assert(result is not NULL);\r\n  if(MY_SPEC.is_vt_mapping_) vt_result_converter_->convert_key_ranges(scan_param_.key_ranges_);//false\r\n  static_cast<ObTableScanIterator*>(result_)->rescan(scan_param_);\r\n  iter_end_ = false;\r\n  \r\n  return ret;\r\n}"}},{"id":"22","label":"ObTableScanIterator::rescan","x":1982.7251480181285,"y":158.6843254067452,"size":[209,40],"category":12,"extra":{"code":"int ObTableScanIterator::rescan(ObTableScanParam& scan_param)\r\n{\r\n  row_iter_ = NULL;\r\n  return iter_.rescan(scan_param);\r\n}"}},{"id":"23","label":"ObTableScanIterIterator::rescan","x":2275.151347457733,"y":155.94789215412072,"size":[237,40],"category":14,"extra":{"code":"int ObTableScanIterIterator::rescan(ObTableScanParam& scan_param)\r\n{\r\n  int ret = OB_SUCCESS;\r\n  range_row_iter_.reset();\r\n  store_row_iter_.rescan(scan_param.key_ranges_, scan_param.range_array_pos_);\r\n  range_row_iter_.init(scan_param.scan_flag_.is_reverse_scan(), store_row_iter_);\r\n  const int64_t range_array_cnt = scan_param.range_array_pos_.count();\r\n  is_reverse_scan_ = scan_param.scan_flag_.is_reverse_scan();\r\n  range_array_cnt_ = 0 == range_array_cnt ? 1 : range_array_cnt;  // zero range means whole range\r\n  range_array_cursor_ = is_reverse_scan_ ? range_array_cnt_ : -1;\r\n  return ret;\r\n}"}},{"id":"24","label":"ObTableScanRangeArrayRowIterator::reset","x":2635.6707808684537,"y":91.18574834477434,"size":[293,40],"category":15,"extra":{"code":"void ObTableScanRangeArrayRowIterator::reset()\r\n{\r\n  is_inited_ = false;\r\n  row_iter_ = NULL;\r\n  cur_row_ = NULL;\r\n  curr_range_array_idx_ = 0;\r\n  is_reverse_scan_ = false;\r\n}\r\n"}},{"id":"25","label":"ObTableScanStoreRowIterator::rescan","x":2622.67725314575,"y":154.7498368841296,"size":[265,40],"category":4,"extra":{"code":"int ObTableScanStoreRowIterator::rescan(const ObRangeArray& key_ranges, const ObPosArray& range_array_pos)\r\n{\r\n  int ret = OB_SUCCESS;\r\n  assert(is_inited_ == true);\r\n  assert(&scan_param_->key_ranges_ != &key_ranges || &scan_param_->range_array_pos_ != &range_array_pos);\r\n  // there's no need to reset main_table_param_ and index_table_param_\r\n  // scan_param only reset query range fields in ObTableScan::rt_rescan()\r\n  range_iter_.reuse();\r\n  main_iter_ = NULL;\r\n  reuse_row_iters();\r\n  main_table_ctx_.reuse();\r\n  index_table_ctx_.reuse();\r\n  is_iter_opened_ = false;\r\n  \r\n  range_iter_.set_scan_param(*scan_param_);\r\n  prepare_table_context(row_filter_);\r\n  open_iter();\r\n  is_iter_opened_ = true;\r\n  return ret;\r\n}"}},{"id":"26","label":"ObRangeIterator::reuse","x":2968.0665871512747,"y":157.7789621319647,"size":[174,40],"category":1,"extra":{"code":"void ObRangeIterator::reuse()\r\n{\r\n  is_inited_ = false;\r\n  scan_param_ = NULL;\r\n  cur_idx_ = 0;\r\n  order_ranges_.reuse();\r\n  rowkey_.reset();\r\n  rowkeys_.reuse();\r\n  range_.reset();\r\n  rowkey_column_orders_ = nullptr;\r\n  rowkey_column_cnt_ = 0;\r\n}"}},{"id":"27","label":"ObSEArrayImpl::reuse","x":3241.455921156799,"y":159.28624344392347,"size":[160,40],"category":0,"extra":{"code":"void reuse()\r\n{\r\n  if (is_destructor_safe()) {\r\n  } else {\r\n    for (int64_t i = 0; i < count_; i++) {\r\n      data_[i].~T();\r\n    }\r\n  }\r\n  count_ = 0;\r\n  error_ = OB_SUCCESS;\r\n}"}},{"id":"28","label":"ObStoreRowkey::~ObStoreRowkey","x":4058.4107241482525,"y":106.97500640498302,"size":[223,40],"category":0,"extra":{"code":"hello,world"}},{"id":"29","label":"ObExtStoreRowkey::reset","x":3248.618381948478,"y":232.7465969369564,"size":[181,40],"category":19,"extra":{"code":"OB_INLINE void reset()\r\n{\r\n  store_rowkey_.reset();\r\n  reset_collation_free_and_range();\r\n}"}},{"id":"30","label":"ObStoreRowkey::reset","x":3532.1976839241925,"y":238.81941005654426,"size":[160,40],"category":20,"extra":{"code":"inline void reset()\r\n{\r\n  key_.reset();\r\n  hash_ = 0;\r\n}"}},{"id":"31","label":"ObRowKey::reset","x":3857.228553002265,"y":236.59389568774586,"size":[125,40],"category":0,"extra":{"code":"void reset()\r\n{\r\n  obj_ptr_ = NULL;\r\n  obj_cnt_ = 0;\r\n}"}},{"id":"32","label":"ObStoreRowkey::reset_collation_free_and_range","x":3569.2138646174344,"y":318.69481871858295,"size":[335,40],"category":0,"extra":{"code":"OB_INLINE void reset_collation_free_and_range()\r\n{\r\n  collation_free_store_rowkey_.reset();\r\n  range_cut_pos_ = -1;\r\n  first_null_pos_ = -1;\r\n  range_check_min_ = true;\r\n}"}},{"id":"33","label":"ObStoreRowkey::reset ","x":3257.148960748752,"y":311.3230625112225,"size":[167,40],"category":0,"extra":{"code":"inline void reset()\r\n{\r\n  key_.reset();\r\n  hash_ = 0;\r\n}"}},{"id":"34","label":"ObExtStoreRange::reset","x":3253.2442849589584,"y":389.60314903168916,"size":[174,40],"category":0,"extra":{"code":"void ObExtStoreRange::reset()\r\n{\r\n  range_.reset();\r\n  ext_start_key_.reset();\r\n  ext_end_key_.reset();\r\n}"}},{"id":"35","label":"ObStoreRange::reset","x":3483.649865875557,"y":394.17687378280095,"size":[153,40],"category":0,"extra":{"code":"inline void reset()\r\n{\r\n  table_id_ = OB_INVALID_ID;\r\n  border_flag_.set_data(0);\r\n  start_key_.assign(NULL, 0);\r\n  end_key_.assign(NULL, 0);\r\n}"}},{"id":"36","label":"ObStoreRowkey::reset  ","x":3880.542178694053,"y":317.92962592443763,"size":[174,40],"category":0,"extra":{"code":"inline void reset()\r\n{\r\n  key_.reset();\r\n  hash_ = 0;\r\n}"}},{"id":"37","label":"ObTableScanStoreRowIterator::reuse_row_iters","x":3010.201063792618,"y":451.46710039216106,"size":[328,40],"category":0,"extra":{"code":"void ObTableScanStoreRowIterator::reuse_row_iters()\r\n{\r\n  if (NULL != single_merge_) {\r\n    single_merge_->reuse();\r\n  }\r\n  if (NULL != get_merge_) {\r\n    get_merge_->reuse();\r\n  }\r\n  if (NULL != scan_merge_) {\r\n    scan_merge_->reuse();\r\n  }\r\n  if (NULL != multi_scan_merge_) {\r\n    multi_scan_merge_->reuse();\r\n  }\r\n  if (NULL != index_merge_) {\r\n    index_merge_->reuse();\r\n  }\r\n  if (NULL != row_sample_iterator_) {\r\n    row_sample_iterator_->reuse();\r\n  }\r\n  if (NULL != block_sample_iterator_) {\r\n    block_sample_iterator_->reuse();\r\n  }\r\n}"}},{"id":"38","label":"ObTableAccessContext::reuse","x":2959.568860591787,"y":524.1561781252441,"size":[209,40],"category":0,"extra":{"code":"void ObTableAccessContext::reuse()\r\n{\r\n  is_inited_ = false;\r\n  timeout_ = 0;\r\n  pkey_.reset();\r\n  query_flag_.reset();\r\n  sql_mode_ = 0;\r\n  store_ctx_ = NULL;\r\n  expr_ctx_ = NULL;\r\n  limit_param_ = NULL;\r\n  if (NULL != lob_locator_helper_) {\r\n    lob_locator_helper_->~ObLobLocatorHelper();\r\n    lob_locator_helper_ = nullptr;\r\n    if (NULL != stmt_allocator_)) {\r\n      stmt_allocator_->free(lob_locator_helper_);\r\n    }\r\n  }\r\n  stmt_allocator_ = NULL;\r\n  allocator_ = NULL;\r\n  stmt_mem_ = NULL;\r\n  if (NULL != scan_mem_) {\r\n    scan_mem_->reuse_arena();\r\n  }\r\n  table_scan_stat_ = NULL;\r\n  block_cache_ws_ = NULL;\r\n  out_cnt_ = 0;\r\n  is_end_ = false;\r\n  trans_version_range_.reset();\r\n  row_filter_ = NULL;\r\n  use_fuse_row_cache_ = false;\r\n  fuse_row_cache_hit_rate_ = 0;\r\n  block_cache_hit_rate_ = 0;\r\n  is_array_binding_ = false;\r\n  range_array_pos_ = nullptr;\r\n  range_array_cursor_ = 0;\r\n}"}},{"id":"39","label":"ObRangeIterator::set_scan_param","x":2972.6319652954303,"y":589.099545698898,"size":[237,40],"category":0,"extra":{"code":"// set scan parameter and do range comparison currently\r\nint ObRangeIterator::set_scan_param(ObTableScanParam& scan_param)\r\n{\r\n  int ret = OB_SUCCESS;\r\n  int64_t array_cnt = scan_param.range_array_pos_.count();\r\n  const int64_t range_cnt = scan_param.key_ranges_.count();\r\n  assert(is_inited_==false);\r\n  if(scan_param.is_get_) {\r\n    assert(range_cnt > 0);\r\n    scan_param_ = &scan_param;\r\n    if (range_cnt > 1) {\r\n      for (int64_t i = 0; OB_SUCC(ret) && i < range_cnt; ++i) {\r\n        const ObRowkey& rowkey = scan_param_->key_ranges_.at(i).get_start_key();\r\n        rowkeys_.push_back(\r\n                ObExtStoreRowkey(ObStoreRowkey(const_cast<ObObj*>(rowkey.get_obj_ptr()), rowkey.get_obj_cnt())));\r\n      }\r\n    }\r\n    \r\n    if (OB_SUCC(ret) && array_cnt > 1) {\r\n      int64_t curr_range_start_pos = 0;\r\n      int64_t curr_range_end_pos = 0;\r\n      for (int64_t i = 0; OB_SUCC(ret) && i < array_cnt; ++i) {\r\n        curr_range_end_pos = scan_param.range_array_pos_.at(i) + 1;\r\n        for (int64_t j = curr_range_start_pos; OB_SUCC(ret) && j < curr_range_end_pos; ++j) {\r\n          set_range_array_idx(i, rowkeys_.at(j));\r\n        }\r\n        curr_range_start_pos = curr_range_end_pos;\r\n      }\r\n    }\r\n  } else {\r\n    scan_param_ = &scan_param;\r\n    array_cnt = 0 == array_cnt ? 1 : array_cnt;\r\n    if (1 == array_cnt) {\r\n      if (0 == range_cnt) {\r\n        ObStoreRange whole_range;\r\n        whole_range.set_whole_range(rowkey_column_orders_, *scan_param_->allocator_);\r\n        ret = order_ranges_.push_back(ObExtStoreRange(whole_range));\r\n      } else {\r\n        order_ranges_.reserve(range_cnt);\r\n        convert_key_ranges(0, range_cnt, 0, *scan_param_->allocator_, order_ranges_);\r\n        // sort the ranges\r\n        if((ObQueryFlag::Forward == scan_param_->scan_flag_.scan_order_ ||\r\n                  ObQueryFlag::Reverse == scan_param_->scan_flag_.scan_order_) &&\r\n              range_cnt > 1) {\r\n          std::sort(order_ranges_.begin(), order_ranges_.end(), RangeCmp(rowkey_column_orders_));\r\n        }    \r\n      } \r\n    } else {\r\n      int64_t range_array_idx = 0;\r\n      int64_t curr_range_start_pos = 0;\r\n      int64_t curr_range_end_pos = 0;\r\n      assert(ObQueryFlag::Forward != scan_param_->scan_flag_.scan_order_ \r\n          && ObQueryFlag::Reverse != scan_param_->scan_flag_.scan_order_);\r\n      order_ranges_.reserve(range_cnt);\r\n      for (int64_t i = 0; OB_SUCC(ret) && i < array_cnt; ++i) {\r\n        curr_range_end_pos = scan_param_->range_array_pos_.at(i) + 1;\r\n        convert_key_ranges(\r\n                curr_range_start_pos, curr_range_end_pos, range_array_idx, *scan_param_->allocator_, order_ranges_);\r\n        ++range_array_idx;\r\n        curr_range_start_pos = curr_range_end_pos;\r\n      }\r\n    }\r\n\r\n    // STORAGE_LOG(DEBUG,\r\n    //     \"set_scan_param returned\",\r\n    //     KP_(rowkey_column_orders),\r\n    //     K(scan_param),\r\n    //     K(scan_param_->key_ranges_),\r\n    //     K(order_ranges_),\r\n    //     K(ret));\r\n  }\r\n  if (OB_SUCC(ret) && scan_param_!=NULL) {\r\n    is_inited_ = true;\r\n  } else {\r\n    reset();\r\n  }\r\n\r\n  return ret;\r\n}"}},{"id":"40","label":"ObSEArrayImpl::reserve","x":3271.608778724127,"y":587.974942940442,"size":[174,40],"category":0,"extra":{"code":"inline int reserve(int64_t capacity)\r\n  {\r\n    int ret = OB_SUCCESS;\r\n    //capacity =1 < capacity_=8\r\n    if (capacity > capacity_) {\r\n      // // memory size should be integer times of block_size_\r\n      // int64_t new_size = capacity * sizeof(T);\r\n      // int64_t plus = new_size % block_size_;\r\n      // new_size += (0 == plus) ? 0 : (block_size_ - plus);\r\n      // T* new_data = reinterpret_cast<T*>(internal_malloc_(new_size));\r\n      // if (OB_NOT_NULL(new_data)) {\r\n      //   if (is_memcpy_safe()) {\r\n      //     memcpy(new_data, data_, count_ * sizeof(T));\r\n      //   } else {\r\n      //     int64_t fail_pos = -1;\r\n      //     for (int64_t i = 0; OB_SUCC(ret) && i < count_; i++) {\r\n      //       if (OB_FAIL(construct_assign(new_data[i], data_[i]))) {\r\n      //         LIB_LOG(WARN, \"failed to copy new_data\", K(ret));\r\n      //         fail_pos = i;\r\n      //       }\r\n      //     }\r\n      //     if (is_destructor_safe()) {\r\n      //     } else {\r\n      //       // if construct assign fails, objects that have been copied should be destructed\r\n      //       if (OB_FAIL(ret)) {\r\n      //         for (int64_t i = 0; i < fail_pos; i++) {\r\n      //           new_data[i].~T();\r\n      //         }\r\n      //       } else {\r\n      //         // if construct assign succeeds, old objects in data_ should be destructed\r\n      //         for (int64_t i = 0; i < count_; i++) {\r\n      //           data_[i].~T();\r\n      //         }\r\n      //       }\r\n      //     }\r\n      //   }\r\n      //   if (OB_SUCC(ret)) {\r\n      //     if (reinterpret_cast<T*>(local_data_buf_) != data_) {\r\n      //       internal_free_(data_);\r\n      //     }\r\n      //     data_ = new_data;\r\n      //     capacity_ = new_size / sizeof(T);\r\n      //   } else {\r\n      //     // construct_assign fails, free new allocated memory, keep data_'s memory not changed\r\n      //     // the result is that reserve is not called at all\r\n      //     internal_free_(new_data);\r\n      //   }\r\n      // } else {\r\n      //   ret = OB_ALLOCATE_MEMORY_FAILED;\r\n      //   LIB_LOG(ERROR, \"no memory\", K(ret), K(new_size), K(block_size_), K(count_), K(capacity_));\r\n      // }\r\n    }\r\n    return ret;\r\n  }"}},{"id":"41","label":"ObRangeIterator::convert_key_ranges","x":3320.6217232787203,"y":662.9166924447718,"size":[265,40],"category":0,"extra":{"code":"int ObRangeIterator::convert_key_ranges(const int64_t range_begin_pos, const int64_t range_end_pos,\r\n    const int64_t range_array_idx, ObIAllocator& allocator, ObIArray<ObExtStoreRange>& store_ranges)\r\n{\r\n  int ret = OB_SUCCESS;\r\n  ObStoreRange store_range;\r\n  for (int64_t i = range_begin_pos; OB_SUCC(ret) && i < range_end_pos; i++) {\r\n    bool is_always_false = false;\r\n    ObNewRange& cur_range = scan_param_->key_ranges_.at(i);\r\n    if(rowkey_column_orders_==NULL) {\r\n      store_range.assign(cur_range);\r\n    } else {\r\n      cur_range.to_store_range(*rowkey_column_orders_, store_range, allocator);\r\n    }\r\n    always_false(store_range, rowkey_column_orders_, is_always_false);\r\n    if(!is_always_false){\r\n      ObExtStoreRange ext_range(store_range);\r\n      set_range_array_idx(range_array_idx, ext_range);\r\n      store_ranges.push_back(ext_range);\r\n    }\r\n  }\r\n  return ret;\r\n}"}},{"id":"42","label":"storage::always_false","x":3660.078051985798,"y":665.0704090305684,"size":[167,40],"category":0,"extra":{"code":"OB_INLINE static int always_false(const ObStoreRange& range, const ObIArray<ObOrderType>* column_orders, bool& is_false)\r\n{\r\n  int ret = OB_SUCCESS;\r\n  int32_t cmp = 0;\r\n\r\n  if(column_orders == NULL)\r\n  {\r\n    cmp = range.get_start_key().compare(range.get_end_key());\r\n  } else {\r\n    range.get_start_key().compare(range.get_end_key(), *column_orders, cmp);\r\n  }\r\n  is_false = (cmp > 0) ||\r\n               (0 == cmp && (!range.get_border_flag().inclusive_start() || !range.get_border_flag().inclusive_end()));\r\n  return ret;\r\n}"}},{"id":"43","label":"ObTableScanStoreRowIterator::prepare_table_context","x":2987.2594350431714,"y":735.7838350268347,"size":[370,40],"category":0,"extra":{"code":"int ObTableScanStoreRowIterator::open_iter()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  ObBatch batch;\r\n  void* buf = NULL;\r\n  if (OB_FAIL(range_iter_.get_next(batch))) {\r\n    if (OB_ITER_END != ret) {\r\n      STORAGE_LOG(WARN, \"fail to get batch range\", K(ret));\r\n    } else {\r\n      ret = OB_SUCCESS;\r\n    }\r\n  } else {\r\n    get_table_param_.partition_store_ = partition_store_;\r\n    get_table_param_.frozen_version_ = scan_param_->frozen_version_;\r\n    get_table_param_.sample_info_ = scan_param_->sample_info_;\r\n    switch (batch.type_) {\r\n      case ObBatch::T_GET: {\r\n        if (NULL == single_merge_) {\r\n          if (NULL == (buf = scan_param_->allocator_->alloc(sizeof(ObSingleMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            single_merge_ = new (buf) ObSingleMerge();\r\n            if (OB_FAIL(init_scan_iter(scan_param_->scan_flag_.is_index_back(), *single_merge_))) {\r\n              STORAGE_LOG(WARN, \"Fail to init single merge, \", K(ret));\r\n            } else {\r\n              use_fuse_row_cache_ = !single_merge_->is_read_memtable_only();\r\n            }\r\n          }\r\n        }\r\n        if (OB_SUCC(ret)) {\r\n          main_table_ctx_.use_fuse_row_cache_ = use_fuse_row_cache_;\r\n          if (OB_FAIL(single_merge_->open(*batch.rowkey_))) {\r\n            STORAGE_LOG(WARN, \"Fail to open multiple get merge iterator, \", K(ret));\r\n          } else {\r\n            main_iter_ = single_merge_;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ObBatch::T_MULTI_GET: {\r\n        if (NULL == get_merge_) {\r\n          if (NULL == (buf = scan_param_->allocator_->alloc(sizeof(ObMultipleGetMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            get_merge_ = new (buf) ObMultipleGetMerge();\r\n            if (OB_FAIL(init_scan_iter(scan_param_->scan_flag_.is_index_back(), *get_merge_))) {\r\n              STORAGE_LOG(WARN, \"Fail to init get merge, \", K(ret));\r\n            } else {\r\n              use_fuse_row_cache_ = !get_merge_->is_read_memtable_only();\r\n            }\r\n          }\r\n        }\r\n        if (OB_SUCC(ret)) {\r\n          main_table_ctx_.use_fuse_row_cache_ = use_fuse_row_cache_;\r\n          if (OB_FAIL(get_merge_->open(*batch.rowkeys_))) {\r\n            STORAGE_LOG(WARN, \"Fail to open multiple get merge iterator, \", K(ret));\r\n          } else {\r\n            main_iter_ = get_merge_;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ObBatch::T_SCAN: {\r\n        if (NULL == scan_merge_) {\r\n          if (OB_ISNULL(buf = scan_param_->allocator_->alloc(sizeof(ObMultipleScanMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            scan_merge_ = new (buf) ObMultipleScanMerge();\r\n            if (OB_FAIL(init_scan_iter(scan_param_->scan_flag_.is_index_back(), *scan_merge_))) {\r\n              STORAGE_LOG(WARN, \"Fail to init scan merge, \", K(ret));\r\n            }\r\n          }\r\n        }\r\n\r\n        if (OB_SUCC(ret)) {\r\n          if (scan_param_->sample_info_.is_block_sample()) {\r\n            if (NULL == block_sample_iterator_) {\r\n              if (OB_ISNULL(buf = scan_param_->allocator_->alloc(sizeof(ObBlockSampleIterator)))) {\r\n                ret = OB_ALLOCATE_MEMORY_FAILED;\r\n                STORAGE_LOG(WARN, \"failed to allocate block_sample_iterator_\", K(ret));\r\n              } else {\r\n                block_sample_iterator_ = new (buf) ObBlockSampleIterator(scan_param_->sample_info_);\r\n              }\r\n            }\r\n            if (OB_SUCC(ret)) {\r\n              if (OB_FAIL(block_sample_iterator_->open(*scan_merge_,\r\n                      scan_param_->scan_flag_.is_index_back() ? index_table_ctx_ : main_table_ctx_,\r\n                      *batch.range_,\r\n                      get_table_param_,\r\n                      scan_param_->scan_flag_.is_reverse_scan()))) {\r\n                STORAGE_LOG(WARN, \"failed to open block_sample_iterator_\", K(ret));\r\n              } else {\r\n                main_iter_ = block_sample_iterator_;\r\n              }\r\n            }\r\n          } else {\r\n            if (OB_FAIL(scan_merge_->open(*batch.range_))) {\r\n              STORAGE_LOG(WARN, \"Fail to open multiple scan merge iterator, \", K(ret), K(*scan_param_));\r\n            } else {\r\n              main_iter_ = scan_merge_;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ObBatch::T_MULTI_SCAN: {\r\n        if (NULL == multi_scan_merge_) {\r\n          if (NULL == (buf = scan_param_->allocator_->alloc(sizeof(ObMultipleMultiScanMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            multi_scan_merge_ = new (buf) ObMultipleMultiScanMerge();\r\n            if (OB_FAIL(init_scan_iter(scan_param_->scan_flag_.is_index_back(), *multi_scan_merge_))) {\r\n              STORAGE_LOG(WARN, \"fail to init multi scan merge\", K(ret));\r\n            }\r\n          }\r\n        }\r\n        if (OB_SUCC(ret)) {\r\n          if (OB_FAIL(multi_scan_merge_->open(*batch.ranges_))) {\r\n            STORAGE_LOG(WARN, \"Fail to open multiple multi_scan merge iterator, \", K(ret));\r\n          } else {\r\n            main_iter_ = multi_scan_merge_;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        ret = OB_INVALID_ARGUMENT;\r\n        STORAGE_LOG(WARN, \"invalid batch type\", K(ret), K(batch.type_));\r\n      }\r\n    }\r\n\r\n    if (OB_SUCC(ret)) {\r\n      if (scan_param_->sample_info_.is_row_sample()) {\r\n        if (NULL == row_sample_iterator_) {\r\n          if (OB_ISNULL(buf = scan_param_->allocator_->alloc(sizeof(ObRowSampleIterator)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"failed to allocate memory\", K(ret));\r\n          } else {\r\n            row_sample_iterator_ = new (buf) ObRowSampleIterator(scan_param_->sample_info_);\r\n          }\r\n        }\r\n        if (OB_SUCC(ret)) {\r\n          if (OB_FAIL(row_sample_iterator_->open(*main_iter_))) {\r\n            STORAGE_LOG(WARN, \"failed to open row_sample_iterator\", K(ret));\r\n          } else {\r\n            main_iter_ = row_sample_iterator_;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (OB_SUCC(ret)) {\r\n      if (scan_param_->scan_flag_.is_index_back()) {\r\n        if (NULL == index_merge_) {\r\n          if (NULL == (buf = scan_param_->allocator_->alloc(sizeof(ObIndexMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            index_merge_ = new (buf) ObIndexMerge();\r\n            if (OB_FAIL(index_merge_->init(main_table_param_, index_table_param_, main_table_ctx_, get_table_param_))) {\r\n              STORAGE_LOG(WARN, \"Fail to init index merge, \", K(ret));\r\n            }\r\n          }\r\n        }\r\n\r\n        if (OB_SUCC(ret)) {\r\n          main_table_ctx_.use_fuse_row_cache_ = use_fuse_row_cache_;\r\n          if (OB_FAIL(index_merge_->open(*main_iter_))) {\r\n            STORAGE_LOG(WARN, \"Fail to open index merge iterator, \", K(ret));\r\n          } else {\r\n            main_iter_ = index_merge_;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n"}},{"id":"44","label":"ObTableScanStoreRowIterator::open_iter","x":2938.5874259157763,"y":793.1756809313099,"size":[286,40],"category":0,"extra":{"code":"int ObTableScanStoreRowIterator::open_iter()\r\n{\r\n  int ret = OB_SUCCESS;\r\n  ObBatch batch;\r\n  void* buf = NULL;\r\n  if (OB_FAIL(range_iter_.get_next(batch))) {\r\n    if (OB_ITER_END != ret) {\r\n      STORAGE_LOG(WARN, \"fail to get batch range\", K(ret));\r\n    } else {\r\n      ret = OB_SUCCESS;\r\n    }\r\n  } else {\r\n    get_table_param_.partition_store_ = partition_store_;\r\n    get_table_param_.frozen_version_ = scan_param_->frozen_version_;\r\n    get_table_param_.sample_info_ = scan_param_->sample_info_;\r\n    switch (batch.type_) {\r\n      case ObBatch::T_GET: {\r\n        if (NULL == single_merge_) {\r\n          if (NULL == (buf = scan_param_->allocator_->alloc(sizeof(ObSingleMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            single_merge_ = new (buf) ObSingleMerge();\r\n            if (OB_FAIL(init_scan_iter(scan_param_->scan_flag_.is_index_back(), *single_merge_))) {\r\n              STORAGE_LOG(WARN, \"Fail to init single merge, \", K(ret));\r\n            } else {\r\n              use_fuse_row_cache_ = !single_merge_->is_read_memtable_only();\r\n            }\r\n          }\r\n        }\r\n        if (OB_SUCC(ret)) {\r\n          main_table_ctx_.use_fuse_row_cache_ = use_fuse_row_cache_;\r\n          if (OB_FAIL(single_merge_->open(*batch.rowkey_))) {\r\n            STORAGE_LOG(WARN, \"Fail to open multiple get merge iterator, \", K(ret));\r\n          } else {\r\n            main_iter_ = single_merge_;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ObBatch::T_MULTI_GET: {\r\n        if (NULL == get_merge_) {\r\n          if (NULL == (buf = scan_param_->allocator_->alloc(sizeof(ObMultipleGetMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            get_merge_ = new (buf) ObMultipleGetMerge();\r\n            if (OB_FAIL(init_scan_iter(scan_param_->scan_flag_.is_index_back(), *get_merge_))) {\r\n              STORAGE_LOG(WARN, \"Fail to init get merge, \", K(ret));\r\n            } else {\r\n              use_fuse_row_cache_ = !get_merge_->is_read_memtable_only();\r\n            }\r\n          }\r\n        }\r\n        if (OB_SUCC(ret)) {\r\n          main_table_ctx_.use_fuse_row_cache_ = use_fuse_row_cache_;\r\n          if (OB_FAIL(get_merge_->open(*batch.rowkeys_))) {\r\n            STORAGE_LOG(WARN, \"Fail to open multiple get merge iterator, \", K(ret));\r\n          } else {\r\n            main_iter_ = get_merge_;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ObBatch::T_SCAN: {\r\n        if (NULL == scan_merge_) {\r\n          if (OB_ISNULL(buf = scan_param_->allocator_->alloc(sizeof(ObMultipleScanMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            scan_merge_ = new (buf) ObMultipleScanMerge();\r\n            if (OB_FAIL(init_scan_iter(scan_param_->scan_flag_.is_index_back(), *scan_merge_))) {\r\n              STORAGE_LOG(WARN, \"Fail to init scan merge, \", K(ret));\r\n            }\r\n          }\r\n        }\r\n\r\n        if (OB_SUCC(ret)) {\r\n          if (scan_param_->sample_info_.is_block_sample()) {\r\n            if (NULL == block_sample_iterator_) {\r\n              if (OB_ISNULL(buf = scan_param_->allocator_->alloc(sizeof(ObBlockSampleIterator)))) {\r\n                ret = OB_ALLOCATE_MEMORY_FAILED;\r\n                STORAGE_LOG(WARN, \"failed to allocate block_sample_iterator_\", K(ret));\r\n              } else {\r\n                block_sample_iterator_ = new (buf) ObBlockSampleIterator(scan_param_->sample_info_);\r\n              }\r\n            }\r\n            if (OB_SUCC(ret)) {\r\n              if (OB_FAIL(block_sample_iterator_->open(*scan_merge_,\r\n                      scan_param_->scan_flag_.is_index_back() ? index_table_ctx_ : main_table_ctx_,\r\n                      *batch.range_,\r\n                      get_table_param_,\r\n                      scan_param_->scan_flag_.is_reverse_scan()))) {\r\n                STORAGE_LOG(WARN, \"failed to open block_sample_iterator_\", K(ret));\r\n              } else {\r\n                main_iter_ = block_sample_iterator_;\r\n              }\r\n            }\r\n          } else {\r\n            if (OB_FAIL(scan_merge_->open(*batch.range_))) {\r\n              STORAGE_LOG(WARN, \"Fail to open multiple scan merge iterator, \", K(ret), K(*scan_param_));\r\n            } else {\r\n              main_iter_ = scan_merge_;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case ObBatch::T_MULTI_SCAN: {\r\n        if (NULL == multi_scan_merge_) {\r\n          if (NULL == (buf = scan_param_->allocator_->alloc(sizeof(ObMultipleMultiScanMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            multi_scan_merge_ = new (buf) ObMultipleMultiScanMerge();\r\n            if (OB_FAIL(init_scan_iter(scan_param_->scan_flag_.is_index_back(), *multi_scan_merge_))) {\r\n              STORAGE_LOG(WARN, \"fail to init multi scan merge\", K(ret));\r\n            }\r\n          }\r\n        }\r\n        if (OB_SUCC(ret)) {\r\n          if (OB_FAIL(multi_scan_merge_->open(*batch.ranges_))) {\r\n            STORAGE_LOG(WARN, \"Fail to open multiple multi_scan merge iterator, \", K(ret));\r\n          } else {\r\n            main_iter_ = multi_scan_merge_;\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      default: {\r\n        ret = OB_INVALID_ARGUMENT;\r\n        STORAGE_LOG(WARN, \"invalid batch type\", K(ret), K(batch.type_));\r\n      }\r\n    }\r\n\r\n    if (OB_SUCC(ret)) {\r\n      if (scan_param_->sample_info_.is_row_sample()) {\r\n        if (NULL == row_sample_iterator_) {\r\n          if (OB_ISNULL(buf = scan_param_->allocator_->alloc(sizeof(ObRowSampleIterator)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"failed to allocate memory\", K(ret));\r\n          } else {\r\n            row_sample_iterator_ = new (buf) ObRowSampleIterator(scan_param_->sample_info_);\r\n          }\r\n        }\r\n        if (OB_SUCC(ret)) {\r\n          if (OB_FAIL(row_sample_iterator_->open(*main_iter_))) {\r\n            STORAGE_LOG(WARN, \"failed to open row_sample_iterator\", K(ret));\r\n          } else {\r\n            main_iter_ = row_sample_iterator_;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (OB_SUCC(ret)) {\r\n      if (scan_param_->scan_flag_.is_index_back()) {\r\n        if (NULL == index_merge_) {\r\n          if (NULL == (buf = scan_param_->allocator_->alloc(sizeof(ObIndexMerge)))) {\r\n            ret = OB_ALLOCATE_MEMORY_FAILED;\r\n            STORAGE_LOG(WARN, \"Fail to allocate memory, \", K(ret));\r\n          } else {\r\n            index_merge_ = new (buf) ObIndexMerge();\r\n            if (OB_FAIL(index_merge_->init(main_table_param_, index_table_param_, main_table_ctx_, get_table_param_))) {\r\n              STORAGE_LOG(WARN, \"Fail to init index merge, \", K(ret));\r\n            }\r\n          }\r\n        }\r\n\r\n        if (OB_SUCC(ret)) {\r\n          main_table_ctx_.use_fuse_row_cache_ = use_fuse_row_cache_;\r\n          if (OB_FAIL(index_merge_->open(*main_iter_))) {\r\n            STORAGE_LOG(WARN, \"Fail to open index merge iterator, \", K(ret));\r\n          } else {\r\n            main_iter_ = index_merge_;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return ret;\r\n}\r\n"}},{"id":"45","label":"ObTableScanRangeArrayRowIterator::init","x":2596.247918404605,"y":917.2425530029267,"size":[286,40],"category":0,"extra":{"code":"int ObTableScanRangeArrayRowIterator::init(const bool is_reverse_scan, ObTableScanStoreRowIterator& iter)\r\n{\r\n  int ret = OB_SUCCESS;\r\n  assert(is_inited_==false);\r\n  is_reverse_scan_ = is_reverse_scan;\r\n  row_iter_ = &iter;\r\n  is_inited_ = true;\r\n  return ret;\r\n}"}}],"edges":[{"source":"0","target":"1"},{"source":"1","target":"2"},{"source":"8","target":"9"},{"source":"0","target":"3"},{"source":"1","target":"8"},{"source":"3","target":"4"},{"source":"8","target":"13"},{"source":"3","target":"14"},{"source":"2","target":"16"},{"source":"16","target":"17"},{"source":"17","target":"18"},{"source":"18","target":"19"},{"source":"19","target":"20"},{"source":"20","target":"21"},{"source":"21","target":"22"},{"source":"22","target":"23"},{"source":"23","target":"24"},{"source":"24","target":"25"},{"source":"25","target":"26"},{"source":"26","target":"27"},{"source":"27","target":"29"},{"source":"29","target":"30"},{"source":"30","target":"31"},{"source":"30","target":"32"},{"source":"33","target":"34"},{"source":"34","target":"35"},{"source":"32","target":"36"},{"source":"29","target":"33"},{"source":"26","target":"37"},{"source":"37","target":"38"},{"source":"38","target":"39"},{"source":"39","target":"40"},{"source":"40","target":"41"},{"source":"41","target":"42"},{"source":"39","target":"43"},{"source":"43","target":"44"},{"source":"25","target":"45"}],"categories":[{"name":"默认样式","fill":"#424242"},{"name":"ObRangeIterator","fill":"#1B5E20"},{"name":"ObSSTable","fill":"#B71C1C"},{"name":"ObMultipleScanMerge","fill":"#FBC02D"},{"name":"ObTableScanStoreRowIterator","fill":"#004D40"},{"name":"ObNestedLoopJoinOp","fill":"#BA68C8"},{"name":"ObTableScanOp","fill":"#673AB7"},{"name":"ObSSTableRowIterator","fill":"#388E3C"},{"name":"ObChunkDatumStore","fill":"#9E9E9E"},{"name":"ObSEArrayImpl","fill":"#3E2723"},{"name":"ObBasicNestedLoopJoinOp","fill":"#9C27B0"},{"name":"ObJoinOp","fill":"#7B1FA2"},{"name":"ObTableScanIterator","fill":"#00BCD4"},{"name":"ObMultipleMerge","fill":"#F57F17"},{"name":"ObTableScanIterIterator","fill":"#4DD0E1"},{"name":"ObTableScanRangeArrayRowIterator","fill":"#0097A7"},{"name":"ObOperator","fill":"#4A148C"},{"name":"ObNewRowIterator","fill":"#006064"},{"name":"变量","fill":"#000000"},{"name":"ObExtStoreRowkey","fill":"#BF360C"},{"name":"ObStoreRowkey","fill":"#E64A19"}]}